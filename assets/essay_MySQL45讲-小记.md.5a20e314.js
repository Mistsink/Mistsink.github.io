import{_ as l,o as i,c as e,a as o}from"./app.4933c4c8.js";const k=JSON.parse('{"title":"MySQL45讲 - 小记","description":"","frontmatter":{"title":"MySQL45讲 - 小记","createTime":"2023/2/19","preview":"MySQL原理相关的阅读笔记"},"headers":[{"level":2,"title":"基础架构","slug":"基础架构","link":"#基础架构","children":[]},{"level":2,"title":"日志系统","slug":"日志系统","link":"#日志系统","children":[]},{"level":2,"title":"事务","slug":"事务","link":"#事务","children":[]},{"level":2,"title":"索引","slug":"索引","link":"#索引","children":[]}],"relativePath":"essay/MySQL45讲-小记.md","lastUpdated":1676872322000}'),t={name:"essay/MySQL45讲-小记.md"},a=o('<h1 id="mysql45讲-小记" tabindex="-1">MySQL45讲 - 小记 <a class="header-anchor" href="#mysql45讲-小记" aria-hidden="true">#</a></h1><blockquote><p>时不时更 ...</p></blockquote><h2 id="基础架构" tabindex="-1">基础架构 <a class="header-anchor" href="#基础架构" aria-hidden="true">#</a></h2><ul><li><p>连接器</p></li><li><p>查询缓存</p><blockquote><p>mysql8.0后已删除该模块</p></blockquote></li><li><p>分析器</p><blockquote><p>编译原理中的词法分析、语义分析，会构建AST，进行语义检查</p></blockquote></li><li><p>优化器</p><blockquote><p>优化查询计划：多表现于选择哪个索引、join时多表的查询顺序等</p></blockquote></li><li><p>执行器</p></li><li><p>存储引擎</p></li></ul><h2 id="日志系统" tabindex="-1">日志系统 <a class="header-anchor" href="#日志系统" aria-hidden="true">#</a></h2><ul><li><p>Redo log</p><blockquote><p>InnoDB特有</p></blockquote><ol><li>存储结构是一个固定大小的循环队列，写满后需清理部分才能继续写</li><li>以 block 形式固定大小存储，在其中 boby 部分追加写内容，覆盖写</li><li>记录物化信息：某个数据页发生了什么变化（猜测应该使用了物化与逻辑的混合模式</li></ol></li><li><p>Binlog</p><blockquote><p>mysql 的 server 层持有的，归档日志</p></blockquote><ol><li>存储结构是一个可追加写的文件，无大小限制</li><li>记录逻辑信息：可理解为将 sql 语句记录下来了</li></ol></li></ul><p>两者间，一是 InnoDB 引擎所有，一是 mysql 层所有，为了保证事务提交后的两日志一致性，采用两阶段提交模型，只有在 redo、bin 都落盘后，事务才能 commit 成功。</p><blockquote><p>两阶段提交：可用于跨系统间的数据一致性</p></blockquote><h2 id="事务" tabindex="-1">事务 <a class="header-anchor" href="#事务" aria-hidden="true">#</a></h2><ul><li><p>特性：原子性、一致性、隔离性、持久性</p></li><li><p>多事务同时执行的时候，可能会出现的问题：脏读、不可重复读、幻读</p></li><li><p>隔离级别：读未提交、读提交、可重复读、串行化</p><ol><li>读未提交：一个事务还未提交，它所做的变更就可以被别的事务看到</li><li>读提交：一个事务提交之后，它所做的变更才可以被别的事务看到</li><li>可重复读：一个事务执行过程中看到的数据是一致的。未提交的更改对其他事务是不可见的</li><li>串行化：对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行</li></ol></li><li><p>配置方法：启动参数transaction-isolation</p></li><li><p>事务隔离的实现：</p><ol><li>读未提交、读提交：引入读写锁</li><li>可重复读：MVCC（多版本并发控制）</li><li>串行化：引入间隙锁或谓词锁等概念</li></ol></li><li><p>回滚日志什么时候删除？</p><blockquote><p>系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。</p></blockquote></li><li><p>什么时候不需要了？</p><blockquote><p>当系统里么有比这个回滚日志更早的read-view的时候。</p></blockquote></li><li><p>为什么尽量不要使用长事务?</p><blockquote><p>长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。</p></blockquote></li><li><p>事务启动方式：</p><ol><li>显式启动事务语句，begin或者start transaction,提交commit，回滚rollback；</li><li>set autocommit=0，该命令会把这个线程的自动提交关掉。这样只要执行一个select语句，事务就启动，并不会自动提交，直到主动执行commit或rollback或断开连接。</li></ol><p>建议使用 方法1</p><blockquote><p>如果考虑多一次交互问题，可以使用commit work and chain语法。在autocommit=1的情况下用begin显式启动事务，如果执行commit则提交事务。如果执行commit work and chain则提交事务并自动启动下一个事务。</p></blockquote></li></ul><p>系统里面应该避免长事务，如果你是业务开发负责人同时也是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢？</p><blockquote><p>在开发过程中，尽可能的减小事务范围，少用长事务，如果无法避免，保证逻辑日志空间足够用，并且支持动态日志空间增长。监控Innodb_trx表，发现长事务报警。</p></blockquote><h2 id="索引" tabindex="-1">索引 <a class="header-anchor" href="#索引" aria-hidden="true">#</a></h2>',13),p=[a];function c(r,n,s,d,u,h){return i(),e("div",null,p)}const _=l(t,[["render",c]]);export{k as __pageData,_ as default};
